<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C++之STL]]></title>
    <url>%2F2019%2F11%2F07%2FC-%E4%B9%8BSTL%2F</url>
    <content type="text"><![CDATA[1 什么是TSTLSTL（Standard Template Library），即标准模板库，是一个具有工业强度的，高效的C++程序库。它被容纳于C++标准程序库（C++ Standard Library）中，是ANSI/ISO C++标准中最新的也是极具革命性的一部分。该库包含了诸多在计算机科学领域里所常用的基本数据结构和基本算法。为广大C++程序员们提供了一个可扩展的应用框架，高度体现了软件的可复用性。 STL的一个重要特点是数据结构和算法的分离。尽管这是个简单的概念，但这种分离确实使得STL变得非常通用。例如，由于STL的sort()函数是完全通用的，你可以用它来操作几乎任何数据集合，包括链表，容器和数组； STL另一个重要特性是它不是面向对象的。为了具有足够通用性，STL主要依赖于模板而不是封装，继承和虚函数（多态性）——OOP的三个要素。你在STL中找不到任何明显的类继承关系。这好像是一种倒退，但这正好是使得STL的组件具有广泛通用性的底层特征。另外，由于STL是基于模板，内联函数的使用使得生成的代码短小高效； 从逻辑层次来看，在STL中体现了泛型化程序设计的思想，引入了诸多新的名词，比如像需求（requirements），概念（concept），模型（model），容器（container），算法（algorithmn），迭代子（iterator）等。与OOP（object-oriented programming）中的多态（polymorphism）一样，泛型也是一种软件的复用技术； 从实现层次看，整个STL是以一种类型参数化的方式实现的，这种方式基于一个在早先C++标准中没有出现的语言特性–模板（template）。 2 STL内容介绍STL中六大组件：①:容器（Container），是一种数据结构，如list，vector，和deques ，以模板类的方法提供。为了访问容器中的数据，可以使用由容器类输出的迭代器；②:迭代器（Iterator），提供了访问容器中对象的方法。例如，可以使用一对迭代器指定list或vector中的一定范围的对象。迭代器就如同一个指针。事实上，C++的指针也是一种迭代器。但是，迭代器也可以是那些定义了operator*()以及其他类似于指针的操作符地方法的类对象；③:算法（Algorithm），是用来操作容器中的数据的模板函数。例如，STL用sort()来对一个vector中的数据进行排序，用find()来搜索一个list中的对象，函数本身与他们操作的数据的结构和类型无关，因此他们可以在从简单数组到高度复杂容器的任何数据结构上使用；④:仿函数（Functor）⑤:适配器（Adaptor）⑥:分配器（allocator） 2.1 容器(container)容器（container）用于存放数据的类模板。可变长数组、链表、平衡二叉树等数据结构在 STL 中都被实现为容器。 STL 中的许多算法（即函数模板），如排序、查找等算法，在执行过程中会对容器中的元素进行比较。这些算法在比较元素是否相等时通常用运算符进行，比较大小通常用&lt;运算符进行，因此，被放入容器的对象所属的类最好重载==和&lt;运算符，以使得两个对象用==和&lt;进行比较是有定义的。容器分为两大类：序列容器(Sequence Container)和关联容器（Associated Container）。 2.1.1 序列容器（Sequence Container）序列容器有以下三种：可变长动态数组 vector、双端队列 deque、双向链表 list。 它们之所以被称为顺序容器，是因为元素在容器中的位置同元素的值无关，即容器不是排序的。将元素插入容器时，指定在什么位置（尾部、头部或中间某处）插入，元素就会位于什么位置。 2.1.2 关联容器(Associated Container)关联容器有以下四种：set、multiset、map、multimap。关联容器内的元素是排序的。插入元素时，容器会按一定的排序规则将元素放到适当的位置上，因此插入元素时不能指定位置。 默认情况下，关联容器中的元素是从小到大排序（或按关键字从小到大排序）的，而且用‘&lt;’运算符比较元素或关键字大小。因为是排好序的，所以关联容器在查找时具有非常好的性能。 除了以上两类容器外，STL 还在两类容器的基础上屏蔽一部分功能，突出或增加另一部分功能，实现了三种容器适配器：栈 stack、队列 queue、优先级队列 priority_queue。 为称呼方便起见，本教程后面将容器和容器适配器统称为容器。 容器都是类模板。它们实例化后就成为容器类。用容器类定义的对象称为容器对象。 例如，vector是一个容器类的名字，vector a;就定义了一个容器对象 a，a 代表一个长度可变的数组，数组中的每个元素都是 int 类型的变量；vector b;定义了另一个容器对象 b，a 和 b 的类型是不同的。本教程后文所说的“容器”，有时也指“容器对象”，读者需要根据上下文自行判别。 任何两个容器对象，只要它们的类型相同，就可以用 &lt;、&lt;=、&gt;、&gt;=、==、!= 进行词典式的比较运算。假设 a、b 是两个类型相同的容器对象，这些运算符的运算规则如下。a == b：若 a 和 b 中的元素个数相同，且对应元素均相等，则a == b的值为 true，否则值为 false。元素是否相等是用==运算符进行判断的。a&lt;b：规则类似于词典中两个单词比较大小，从头到尾依次比较每个元素，如果发生 a 中的元素小于 b 中的元素的情况，则a&lt;b的值为 true；如果没有发生 b 中的元素小于 a 中的元素的情况，且 a 中的元素个数比 b 少，a&lt;b的值也为 true；其他情况下值为 false。元素比较大小是通过&lt;运算符进行的。a != b：等价于 !(a == b)。a &gt; b：等价于 b &lt; a。a &lt;= b：等价于 !(b &lt; a)。a &gt;= b：等价于 !(a &lt; b)。 所有容器都有以下两个成员函数： 12int size()：//返回容器对象中元素的个数。bool empty()：//判断容器对象是否为空。 顺序容器和关联容器还有以下成员函数： 123456begin()：返回指向容器中第一个元素的迭代器。end()：返回指向容器中最后一个元素后面的位置的迭代器。rbegin()：返回指向容器中最后一个元素的反向迭代器。rend()：返回指向容器中第一个元素前面的位置的反向迭代器。erase(...)：从容器中删除一个或几个元素。该函数参数较复杂，此处省略。clear()：从容器中删除所有元素。 如果一个容器是空的，则 begin() 和 end() 的返回值相等，rbegin() 和 rend() 的返回值也相等。 顺序容器还有以下常用成员函数：front()：返回容器中第一个元素的引用。back()：返回容器中最后一个元素的引用。push_back()：在容器末尾增加新元素。pop_back()：删除容器末尾的元素。insert(…)：插入一个或多个元素。该函数参数较复杂，此处省略。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[她]]></title>
    <url>%2F2019%2F09%2F11%2F%E5%A5%B9%2F</url>
    <content type="text"><![CDATA[有女朋友，但遇到更好的怎么办。 大二的时候，宿舍有个哥们，和女朋友高一开始谈了五年多，大学异地，刚好学生会一个女同学看上了他，女同学很漂亮，总之条件比哥们的女朋友要好很多。那哥们愁的天天宿舍打转，一边挺喜欢女同学，一边觉得对不起女朋友，问我们怎么办，然后寝室长说了一句话，我至今难忘。他说：做为你的兄弟，自然希望你能和更优秀的女孩子在一起，但是做为男人，我觉得你应该对你女朋友的青春负责，毕竟她没有做错什么，她也可能为你拒绝过很多男生，既然当初你选择了她，就要有所担当。后来，我步入社会，越发认识到这是世上的爱情分两种，一种是人性本能带来的刺激，比如看到美女就想泡，二真正成熟的爱，是用时间用经历去沉淀，共同经营，共同承担责任，可以因为现任不好而分手，但尽量不要因为别人更好而分手，永远有人更好，但眼下的既是最好的]]></content>
  </entry>
  <entry>
    <title><![CDATA[that girl]]></title>
    <url>%2F2019%2F08%2F27%2Fthat-girl%2F</url>
    <content type="text"><![CDATA[1.20岁刚出头是男孩最穷的时候 20岁刚出头是女孩子最漂亮的时候 贫穷对我来说只是晚上吃馒头和吃牛排的区别 无损我的快乐 可当我爱上一个姑娘的时候 我才深深的感受到了什么是贫穷所带来的自卑.我只恨我自己，在最没有能力的年纪遇到了最想照顾一生的人。 2.他独自过了一段，连一个陌生来电都会心跳加速的时期，最终变成，看到和她背影相似的人，都心如止水的现在。 3.人说，林深时见鹿，海蓝时见鲸，梦醒时见你。 可实际，林深时雾起，海蓝时浪涌，梦醒时也许未见鹿，未见鲸，亦未见你。但是，鹿踏雾而来，鲸随浪儿起，你没回头，又怎知我没来过。]]></content>
      <categories>
        <category>网易云评论</category>
      </categories>
      <tags>
        <tag>网易云评论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rain after summer]]></title>
    <url>%2F2019%2F08%2F14%2Frain-after-summer%2F</url>
    <content type="text"><![CDATA[世界上有一条最寂寞的鲸鱼叫Alice，它发出的频率比正常鲸鱼高一倍，唱歌时没人听见，难过时没人理睬。这个世界上，有很多很多人都是Alice。我们都会寂寞孤独渴望陪伴，但愿这些时刻我们可以给彼此一个拥抱，相互温暖 多年后，汤姆猫老了，主人再也不喜欢他了，新来的小猫咪也欺负他，一天他们再次把汤姆的食物丢出门外。汤姆已经没有力气跑了，他迈着年老的步伐出去捡回那一块沾满灰尘的奶酪，轻轻地放在墙角那结满蜘蛛网的老鼠洞前，即使他已经不在了。 躲了一辈子雨，雨会不会难过。 养了13年的乌龟从不在我房间过夜，它喜欢潮湿黑暗的角落。但这几天它一直呆在我房间，我上床睡觉它便爬过来紧挨床沿。夜里它来回走动像极人走路，我起身把它抱出去，清晨醒来见它又爬回来。我开玩笑低头说：你找我有事啊？今天它安静的死去了，我难过是因为它一直在和我说，再见了。 弟子问老师：“您能谈谈人类的奇怪之处吗？”老师答道：“他们急于成长，然后又哀叹失去的童年；他们以健康换取金钱，不久后又想用金钱恢复健康。他们对未来焦虑不已，却又无视现在的幸福。因此，他们既不活在当下，也不活在未来.他们活着仿佛从来不会死亡。临死前，又仿佛从未活过。]]></content>
      <categories>
        <category>网易云评论</category>
      </categories>
      <tags>
        <tag>网易云评论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小句]]></title>
    <url>%2F2019%2F08%2F14%2F%E5%B0%8F%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[山川不相忘，奈何可奈何？ 雨打梨花深闭门，忘了青春，误了青春。行也思君，坐也思君。 碧野朱桥当日事，人不见，水空流。便做春江都是泪，流不尽，许多愁。 虞美人晚春三月开红豆，却道无人留。庭前寒冷谁消瘦，月下独酌，入喉一身愁。芙蓉花开蝶犹在，只江水东流。悲欢离合总是情，隔岸杨柳，一夜相思愁.]]></content>
      <categories>
        <category>小短句</category>
      </categories>
      <tags>
        <tag>文字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python]]></title>
    <url>%2F2019%2F08%2F08%2Fpython%2F</url>
    <content type="text"><![CDATA[函数式编程装饰器由于函数也是一个对象，而且函数对象可以被赋值给变量，所以，通过变量也能调用该函数。 1234def now(): print('2019-8-8')f = nowf() 12019-8-8 函数对象有一个name属性，可以拿到函数的名字 12now._name_f._name_ 12nownow 现在，假设我们要增强now()函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改now()函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）idle]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My first blog]]></title>
    <url>%2F2019%2F08%2F04%2FMy-first-blog%2F</url>
    <content type="text"><![CDATA[博客第一篇文章三级标题 列表1 列表2 a子列表 b子列表 列表3 侧面的链接图标用Font Awesome网站的图标 设置网站图标,要下载两个图标，16x16和32x32的. 知乎字体是斜线的字体加粗了呢* 粗斜体*&lt;html&gt;&lt;/html&gt; 123456&lt;html&gt; &lt;head&gt; &lt;title&gt;这是标题哦&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>互联网</tag>
      </tags>
  </entry>
</search>
